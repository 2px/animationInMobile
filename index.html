<!DOCTYPE html>
<html lang="en" class="no-js">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="css/animation.css" />
</head>

<body>
    <div class="container">
        <section>
            <div id="component" class="component component-small">
                <ul class="itemwrap">
                    <li class="current" data-index='1'><img src="img/1.jpg" alt="img01" /></li>
                    <li><img src="img/2.jpg" alt="img02" /></li>
                    <li><img src="img/man.png" alt="img02" /></li>
                    <li data-index='4' ><img src="img/woman.jpg" alt="img02" /></li>
                </ul>
                <nav>
                    <a class="prev" href="#">Previous item</a>
                    <a class="next" href="#">Next item</a>
                </nav>
            </div>
        </section>
    </div>
</body>
<script src="js/zepto.min.js"></script>
<script type="text/javascript">
var slide = (function() {
   //每个动画按照前后顺序排列，不能打乱 APrev, ANext, BPrev, BNext 样式命名最好解耦出来，比如按照left或者right或者up和down来命名比较好
    var animations = ['navOut-left', 'navIn-left', 'navOut-right', 'navIn-right'];
    //去掉浏览器的默认滑动行为
    document.addEventListener('touchmove', function (event) {
       event.preventDefault();
    }, false);
    //负责判断滑动对象
    function _judeElement(current, direction) {
        var children = current.parent().children();
        var len = children.length - 1;
        var index = current.index();
        var fn = {
            left: function() {
                return (index == len ? children.first() : current.next());
            },
            right: function() {
                return (index == 0 ? children.last() : current.prev());
            }
        };
        return fn[direction]();
    }
    //获取其他样式
    function _getOtherCls(cls) {
        var clss = [];
        for(var i=0, l = animations.length; i<l; i++) {
            if(animations[i] === cls) continue;
            clss.push(animations[i]);
        }
        return clss.join(' ');
    }

    //判断应用样式
    function _judeClass(direction) {
        var currentAddCls = 'navOut-'+direction;
        var brotherAddCls = animations[animations.indexOf(currentAddCls) + 1];
        
        return {
            currentAddCls: currentAddCls,
            currentRemoveCls: 'current ' + _getOtherCls(currentAddCls),
            brotherAddCls: 'current ' + brotherAddCls,
            brotherRemoveClas: _getOtherCls(brotherAddCls)
        };
    }
    //负责动画行为
    function animation (current, direction) {
        var currentElement = current;
        var el = _judeElement(currentElement, direction);
        var animationObj = _judeClass(direction);
        current.removeClass(animationObj.currentRemoveCls).addClass(animationObj.currentAddCls);
        el.removeClass(animationObj.brotherRemoveClas).addClass(animationObj.brotherAddCls);
    }

    return animation;

})();

$('.next').bind('click', function() {
    slide($('.current'), 'right');
})
$('.prev').bind('click', function() {
    slide($('.current'), 'left');
});
$('img').on('swipeLeft', function(){
    slide($(this).parent(), 'left');
});
$('img').on('swipeRight', function(){
    slide($(this).parent(), 'right');
});
</script>

</html>
